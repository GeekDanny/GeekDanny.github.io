<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>Vulkan 导读2: Command Buffer 和内存管理 | 极客丹尼</title><meta name="description" content="Vulkan 导读2: Command Buffer 和内存管理"><meta name="keywords" content="Vulkan"><meta name="author" content="Danny Song"><meta name="copyright" content="Danny Song"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://raw.githubusercontent.com/geekdanny/images/master/kirito.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Vulkan 导读2: Command Buffer 和内存管理"><meta name="twitter:description" content="Vulkan 导读2: Command Buffer 和内存管理"><meta name="twitter:image" content="https://broadgeek.com![NFrL2w](https://raw.githubusercontent.com/geekdanny/images/master/blog/NFrL2w.png)"><meta property="og:type" content="article"><meta property="og:title" content="Vulkan 导读2: Command Buffer 和内存管理"><meta property="og:url" content="https://broadgeek.com/2021/01/11/7c7/"><meta property="og:site_name" content="极客丹尼"><meta property="og:description" content="Vulkan 导读2: Command Buffer 和内存管理"><meta property="og:image" content="https://broadgeek.com![NFrL2w](https://raw.githubusercontent.com/geekdanny/images/master/blog/NFrL2w.png)"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://broadgeek.com/2021/01/11/7c7/"><link rel="next" title="Vulkan 导读1: 下一代图形API" href="https://broadgeek.com/2021/01/11/59e9/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="极客丹尼" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">极客丹尼</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://raw.githubusercontent.com/geekdanny/images/master/avatar.jpg" onerror="onerror=null;src='https://raw.githubusercontent.com/geekdanny/images/master/loading404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">33</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">36</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">12</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Getting-started-with-command-buffers"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">Getting started with command buffers</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#显式同步（Explicit-Synchronization）"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">显式同步（Explicit Synchronization）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Command-Buffer-and-Queues"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">Command Buffer and Queues</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#The-Order-of-Execution"><span class="toc_mobile_items-number">1.2.1.</span> <span class="toc_mobile_items-text">The Order of Execution</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Recording-Command-Buffers"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">Recording Command Buffers</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Queue-Submission"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">Queue Submission</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Queue-Waiting"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">Queue Waiting</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Managing-Memory-in-Vulkan"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">Managing Memory in Vulkan</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Host-Memory"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">Host Memory</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Device-Memory"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">Device Memory</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#总结"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">总结</span></a></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Getting-started-with-command-buffers"><span class="toc-number">1.</span> <span class="toc-text">Getting started with command buffers</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#显式同步（Explicit-Synchronization）"><span class="toc-number">1.1.</span> <span class="toc-text">显式同步（Explicit Synchronization）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Command-Buffer-and-Queues"><span class="toc-number">1.2.</span> <span class="toc-text">Command Buffer and Queues</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Order-of-Execution"><span class="toc-number">1.2.1.</span> <span class="toc-text">The Order of Execution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Recording-Command-Buffers"><span class="toc-number">1.3.</span> <span class="toc-text">Recording Command Buffers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Queue-Submission"><span class="toc-number">1.4.</span> <span class="toc-text">Queue Submission</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Queue-Waiting"><span class="toc-number">1.5.</span> <span class="toc-text">Queue Waiting</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Managing-Memory-in-Vulkan"><span class="toc-number">2.</span> <span class="toc-text">Managing Memory in Vulkan</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Host-Memory"><span class="toc-number">2.1.</span> <span class="toc-text">Host Memory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Device-Memory"><span class="toc-number">2.2.</span> <span class="toc-text">Device Memory</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(![NFrL2w](https://raw.githubusercontent.com/geekdanny/images/master/blog/NFrL2w.png))"><div id="post-info"><div id="post-title"><div class="posttitle">Vulkan 导读2: Command Buffer 和内存管理</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2021-01-11<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2021-01-11</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/GPU/">GPU</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon fa-fw" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">1.5k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon fa-fw" aria-hidden="true"></i><span>阅读时长: 6 分钟</span><div class="post-meta-pv-cv"><span class="post-meta__separator">|</span><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><html><head></head><body><p>导读2 主要是讲解第五章，之所以跳过2，3，4章是因为这三章关键概念很少，更多的是围绕Vulkan初始化阶段的准备工作。第五章重点讲解了CB和内存的概念，值得对其细节进行整理。</p>
<p>一个command buffer就是a collection of commands. Command buffer 会被提交到一个合适的 hardware queue 让GPU来处理。driver会fetches和validates并compiles这些command buffers，然后再把它们交给GPU来处理。这一章节主要围绕command buffers 和 memory allocation的讲解了以下topics：</p>
<ul>
<li>Getting started with command buffers</li>
<li>Understanding the command pool and command buffer APIs</li>
<li>Recording command buffers</li>
<li>Implementing the command buffer wrapper class</li>
<li>Managing memory in Vulkan</li>
</ul>
<h1 id="Getting-started-with-command-buffers"><a href="#Getting-started-with-command-buffers" class="headerlink" title="Getting started with command buffers"></a>Getting started with command buffers</h1><p><strong>名词解释</strong></p>
<p><strong>Command Buffer</strong>：a command buffer is a buffer or collection of commands in a single unit.</p>
<p>一个CB 记录了多个可以被App调用和执行的Vulkan API commands。CB一旦被baked后，是可以<strong>反复使用</strong>的。CB们按照App的调用commands的次序来依次记录commands。这些commands是用来承载不同类型的jobs。这些jobs包括：binding vertex buffer， pipeline binding， recording Render Pass Commands， setting viewport and scissor， specifying drawing commands， controlling copy operations on imag and buffer contents 等。</p>
<p>Command Buffer  有两种：</p>
<ul>
<li><strong>Primary command buffers</strong>：这种buffer是SCB的owners，并负责执行SCB。PCB是可以被直接提交到queues上。</li>
<li><strong>Secondary command buffers：</strong>SCB是通过PCB来执行的。他们不可以直接被提交到queues上。</li>
</ul>
<p>一个APP可能会有成百上千个CB。由于数量巨大，所以CB都是通过command pool来创建的， CB本身是无法直接被创建的。</p>
<p><a href="https://raw.githubusercontent.com/geekdanny/images/master/blog/640-20210111143521475.jpg" target="_blank" rel="noopener" data-fancybox="group" data-caption="图片" class="fancybox"><img alt="图片" title="图片" data-src="https://raw.githubusercontent.com/geekdanny/images/master/blog/640-20210111143521475.jpg" class="lazyload"></a></p>
<p>CB是persistent的；它们一旦被创建，就可以被持续地复用。如果一个CB不再有用了，它也可以通过reset command来被renew，然后为下一个recording做好准备。这种做法跟“destroy 再create”的做法比就显得更加高效，</p>
<h2 id="显式同步（Explicit-Synchronization）"><a href="#显式同步（Explicit-Synchronization）" class="headerlink" title="显式同步（Explicit Synchronization）"></a>显式同步（Explicit Synchronization）</h2><p>CB 是由每一个thread所负责的 command buffer pool来创建的。这种做法避免了不同threads之间需要显式地同步去创建CB。但是App必须要对在不同的threads之间共用的CBs做同步不管理。</p>
<p>书中用了一段话比较了OpenGL跟Vulkan两者，把CB提交给GPU过程的区别。值得留意：</p>
<p>*”Another differentiation is the submission of the command buffers in OpenGL: command* <em>buffers are pushed behind the scenes and are not in control of the application. An</em> <em>application that submits the commands has no guarantee when those jobs will be executed.</em> <em>This is because OpenGL executes command buffers in batches. It waits for the commands to</em> <em>build the batch and then it dispatches them together. On the other hand, Vulkan gives</em> <em>explicit control to the command buffer to allow the processing up front by submitting it to</em> <em>the desired queue.” P120, 《Learn Vulkan》</em></p>
<p>CB 包含了很多个 commands。 这些Commands可以归类为三种：</p>
<ul>
<li><strong>Action</strong>: This command performs operations such as draw, dispatch, clear, copy,query/timestamp operations, and begin/end a subpass</li>
<li><strong>State management:</strong> This includes descriptor sets, bind pipelines, and buffers, and it is used to set the dynamic state, push constants, and the Render Pass/subpass state</li>
<li><strong>Synchronization:</strong> These commands are used for synchronization: pipeline barriers, set events, wait events, and Render Pass/subpass dependencies</li>
</ul>
<p><a href="https://mmbiz.qpic.cn/mmbiz_png/Ht4ZIhKGnFG8kibdNba3kbMkg4Vjwnwlgib2V9cDqc6JYlrz025Cay1O5qnl4yX8BPaRjy7q7nSibXibrY1NlkjnhA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" target="_blank" rel="noopener" data-fancybox="group" data-caption="图片" class="fancybox"><img alt="图片" title="图片" data-src="https://mmbiz.qpic.cn/mmbiz_png/Ht4ZIhKGnFG8kibdNba3kbMkg4Vjwnwlgib2V9cDqc6JYlrz025Cay1O5qnl4yX8BPaRjy7q7nSibXibrY1NlkjnhA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></a></p>
<h2 id="Command-Buffer-and-Queues"><a href="#Command-Buffer-and-Queues" class="headerlink" title="Command Buffer and Queues"></a>Command Buffer and Queues</h2><p>CB被提交到 hardware queue后会被异步处理掉。 队列提交可以通过batching CBs来一次完成。Vulkan有一种deferred command model：它可以让CB里对<strong>draw calls的收集</strong>和<strong>提交</strong>分别作为两个不同的operations来单独处理。这种做法方便了App可以在大部分场景下针对submission 做出适当的优化， 而这恰恰是OpenGL很难做到的。</p>
<p>Vulkan 提供对硬件queue的逻辑view。每一个逻辑view都关联着一个hardware queue。 一个单一的hardware queue可以用多个逻辑queues。</p>
<h3 id="The-Order-of-Execution"><a href="#The-Order-of-Execution" class="headerlink" title="The Order of Execution"></a>The Order of Execution</h3><p>CBs 可以被提交一个single queue或者多个queues上：</p>
<ul>
<li><strong>Single queue submission:</strong> Multiple command buffers submitted to a single queue may be executed or overlapped. In single queue submission, a command buffer must obey the order of the execution of operations as per the command order and the API order specification. This book only covers the submission commands used for vkQueueSubmit; it does not cover sparse memory binding command buffers (through vkQueueBindSparse).</li>
<li><strong>Multiple queue submission:</strong> The command buffers submitted to multiple queues may be executed in any order unless explicit ordering constraints are applied through the synchronization mechanism via semaphores and fences.</li>
</ul>
<h2 id="Recording-Command-Buffers"><a href="#Recording-Command-Buffers" class="headerlink" title="Recording Command Buffers"></a><strong>Recording Command Buffers</strong></h2><p>一个CB是通过vkBeginCommandBuffer()和 vkEndCommandBuffer()这两个 APIs 来记录的。这两者之间的scope就是具体的Vulkan commands 被记录的范围。下图显示了一个Render Pass Instance在这两个API之间被记录的过程：</p>
<p><a href="https://mmbiz.qpic.cn/mmbiz_png/Ht4ZIhKGnFG8kibdNba3kbMkg4VjwnwlgFw70RSHzTHwf7J7FqXzkZEH84RictdoDO0mlfHLtSrOvcTWn9tZAPLQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" target="_blank" rel="noopener" data-fancybox="group" data-caption="图片" class="fancybox"><img alt="图片" title="图片" data-src="https://mmbiz.qpic.cn/mmbiz_png/Ht4ZIhKGnFG8kibdNba3kbMkg4VjwnwlgFw70RSHzTHwf7J7FqXzkZEH84RictdoDO0mlfHLtSrOvcTWn9tZAPLQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></a></p>
<h2 id="Queue-Submission"><a href="#Queue-Submission" class="headerlink" title="Queue Submission"></a><strong>Queue Submission</strong></h2><p>当一个CB完成记录后，它就可以被提交到一个queue上了。vkQueueSubmit() API 用来把一个CB或者在多个CB提交到正确的queue上。</p>
<h2 id="Queue-Waiting"><a href="#Queue-Waiting" class="headerlink" title="Queue Waiting"></a>Queue Waiting</h2><p>当CBs被提交到queue后，App要等待所提交的工作被完成，才可以接受一下个batch。等待queue的API 是 vkQueueWaitIdle() API。</p>
<h1 id="Managing-Memory-in-Vulkan"><a href="#Managing-Memory-in-Vulkan" class="headerlink" title="Managing Memory in Vulkan"></a>Managing Memory in Vulkan</h1><p>Vulkan 将内存分成两种：<strong>host memory</strong> 和 <strong>device memory</strong>。host memory被device memory 慢，但是可用的地方比较多。device memory 对GPU可见，所以更快。</p>
<h2 id="Host-Memory"><a href="#Host-Memory" class="headerlink" title="Host Memory"></a><strong>Host Memory</strong></h2><p>书中段落开头一段话很重要，摘要如下：</p>
<p><em>“Vulkan makes use of host memory to store API internal data structures in the implementation. Vulkan provides allocators, which allow an application to control memory allocation on behalf of host memory. If the application does not use allocators, then the Vulkan implementation uses a default allocation scheme to reserve a memory slot for its data structures.” （p137， 《Learn Vulkan》）</em></p>
<p>这段话可以总结为以下信息：</p>
<ul>
<li>host memory 是用来存储API internal data strucutures</li>
<li>App通过Allocator来分配和创建host 的memory</li>
<li>如果APP不通过allocator，那么Vulkan使用默认alllocation scheme来为data structures保留内存的slot。</li>
</ul>
<p>至于内存的分配管理则是用callback来完成的：</p>
<p><em>“Host memory is managed by the VkAllocationCallbacks control structure, which is passed to Vulkan APIs for custom management of host memory.”</em></p>
<h2 id="Device-Memory"><a href="#Device-Memory" class="headerlink" title="Device Memory"></a><strong>Device Memory</strong></h2><p>书中段头解释的很清楚： </p>
<p><em>“Device memory is GPU memory that is visible to the physical device. The physical device can read its memory regions directly. Device memory is very close to the physical device, and thus provides faster performance than host memory. Image objects, buffers objects, and uniform buffer objects are all allocated on device memory.”</em> P139，《Learn Vulkan》</p>
<p>App 有责任通过调用 <em>vkGetPhysicalDeviceMemoryProperties()</em>API 来查询物理设备上可用的memory heaps 和 meomory properities，并更好的分配这些资源。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>书中在这一章节介绍了CB和meomory allocation， 并给出了API的调用细节，导读里我没有针对具体的代码细节展开，代码可以自己看，很容易理解。Vulkan所分配的资源可以分为两种：<strong>buffers</strong> 和 <strong>images</strong>。我们会在导读3介绍images resources；然后在导读4里介绍 buffer resource，Render Pass，Framebuffer 和 shaders。所以导读4也将是最重要的一章！</p>
<p>引用： 《Learning Vulkan》</p>
</body></html></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Danny Song</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://broadgeek.com/2021/01/11/7c7/">https://broadgeek.com/2021/01/11/7c7/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://broadgeek.com">极客丹尼</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Vulkan/">Vulkan    </a></div><div class="post_share"><div class="social-share" data-image="![NFrL2w](https://raw.githubusercontent.com/geekdanny/images/master/blog/NFrL2w.png)" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://raw.githubusercontent.com/geekdanny/images/master/wechat.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://raw.githubusercontent.com/geekdanny/images/master/alipay.jpg" alt="支付寶"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2021/01/11/59e9/"><img class="next_cover lazyload" data-src="https://raw.githubusercontent.com/geekdanny/images/master/blog/640.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>Vulkan 导读1: 下一代图形API</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2021/01/11/59e9/" title="Vulkan 导读1: 下一代图形API"><img class="relatedPosts_cover lazyload"data-src="https://raw.githubusercontent.com/geekdanny/images/master/blog/640.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-01-11</div><div class="relatedPosts_title">Vulkan 导读1: 下一代图形API</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = true == true ? true : false;
var verify = false == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'k2Wixoxbl6pkWGvMvGiokWTD-MdYXbMMI',
  appKey:'oGRBxV8zDB1hP72TQ6EoYj81',
  placeholder:'Please leave your footprints',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-cn',
  recordIP: true
});</script></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By Danny Song</div><div class="footer_custom_text">回忆是一种重逢 遗忘是一种自由</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.9}});</script></body></html>